# CPUの高速化技法

## CPUの仕事

基本的にメモリから命令を読み込み，命令を実行し，結果をメモリに書き込む，の繰り返し

IF (Instruction Fetch: 命令読み込み)  
↓  
ID (Instruction Decode: 命令デコード)  
↓  
DF (Data Fetch: データ読み込み)  
↓  
EX (Execute: 命令実行)  
↓  
WB (Write Back: 結果書き出し)  

## パイプライン処理

前の命令の実行が終わる前に，次の命令を流れ作業で処理して実行して効率を向上する  

パイプライン無し


|time|1|2|3|4|5|6|7|8|9|10|
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 命令1 |IF  | ID | DF | EX | WB | | | | | |
| 命令2 |  |  |  |  |  |IF|ID|DF|EX|WB|


パイプラインあり

|time|1|2|3|4|5|6|7|8|9|10|
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 命令1 |IF  |ID  |DF  |EX  |WB  |  |  |  |  |  |
| 命令2 |  |IF  |ID  |DF  |EX  |WB  |  |  |  |  |
| 命令3 |  |  |IF  |ID  |DF  |EX  |WB  |  |  |  |
| 命令4 |  |  |  |IF  |ID  |DF  |EX  |WB  |  |  |
| 命令5 |  |  |  |  |IF  |ID  |DF  |EX  |WB  |  |
| 命令6 |  |  |  |  |  |IF  |ID  |DF  |EX  |WB  |

パイプライン無しの場合1命令を実行するのに5クロックかかっていたのが  
パイプラインありの場合実質的に1命令1クロックで実行できるようになった。

## パイプライン処理の問題

以下のようなケースでは理想的なパイプライン処理が行えない  

### 1. 直前の命令の結果をオペランドにする命令の場合(データハザード)  
```
a = b + c;  
d = a + e;　　// a の値が分からないと命令が実行できない
```
### 2. 直前の命令の結果により分岐する命令の場合(制御ハザード)  
```
if (cond) {　　// cond の値が分からないとどちらの命令を実行するべきか分からない  
  a = b + c;  
} else {  
  a = b + d;  
}  
```
### 3. リソースが競合する場合(構造ハザード)
例えばIFとWBを同時に行おうとする場合，MMU(メモリ管理ユニット)の競合が発生する

## アウトオブオーダー実行

### 概要

そのままでは効率的にパイプライン処理できない命令を並び替えて，効率的に実行する機能  

アウトオブオーダー無し
```
a = b + c;  // 1行目が終わらないと
d = a + e;  // 2行目は実行できないが
f = g + h;  // 3行目は関係なく実行できる
```
↓
アウトオブオーダーあり
```
a = b + c;  // このように並び替えると
f = g + h;  // パイプラインで実行できるようになる
d = a + e;  // 
```
### もう少し詳しく
例えば命令1が整数演算，命令2が命令1の結果に依存する整数演算，命令2が浮動小数点演算だとする。

アウトオブオーダー無しの場合ではパイプライン処理の流れは次のようになる。

|time|1|2|3|4|5|6|7|8|9|10|11|
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 命令1 |IF  |ID  |DF  |EX  |WB  |  |  |  |  |  |  |
| 命令2 |  |IF  |ID  |X  |X  |DF  |EX  |WB  |  |  |  |
| 命令3 |  |  |IF  |ID  |X |X |DF  |EX(1) |EX(2) | EX(3) |WB   | 

直前の命令が完了するまで次の命令が実行できない → 実行に時間がかかる命令が一つあると，パイプライン全体の効率が低下する。

アウトオブオーダーありの場合のパイプライン処理の流れ

|time|1|2|3|4|5|6|7|8|9|
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 命令1 |IF  |ID  |DF  |EX  |WB  |  |  |  |  | 
| 命令2 |  |IF  |ID  |X  |X  |DF  |EX  |WB  |  |   
| 命令3 |  |  |IF  |ID  |DF  |EX(1)|EX(2) |EX(3) |WB   | 

データの依存関係やリソースの競合が無い場合，直前の命令の完了を待たずに実行できる命令から先に実行する。
完了した命令の結果はバッファ(リオーダーバッファ)に格納し，レジスタやメモリへの値の書き出しはプログラム順になるようにする。


## 分岐予測

条件分岐命令の分岐結果を予測してパイプライン処理を行う機能。
分岐結果が分かる前に分岐先のアドレスの命令をあらかじめ読み込んで計算を行う。
分岐予測が当たっていればそのまま計算を続けるが，分岐結果が外れると計算の結果を破棄して命令の読み込みからやり直す。

```
// よくある条件分岐
for (int i = 0; i < 1000; i++) {
   sum += array[i];
}
```
上のコードでは1回のループ毎にfor文を続けるか抜けるかの条件分岐が発生している。
しかし，for文を抜ける分岐が発生するのは1回だけで，残りの999回はfor文を続ける方向の分岐である。
したがって，とりあえずfor文を続ける方向で計算を進めれば大きな効率化が実現できる。

### 飽和カウンタ

命令の分岐結果の履歴を保存しておき，過去の履歴から分岐の結果を予測する方法。
2ビットのカウンタを数千個用意し，条件分岐命令のアドレスの下位数十ビットをカウンタに割り振る。
分岐が発生したらカウンタをインクリメント，発生しなかったらデクリメントする。
カウンタの値が2以上なら分岐が発生するものとして計算を行う。

例えば，次のようなプログラムがあり2行目で条件分岐が実行されるとする。

|addr | inst | 意味 | 
| --- | --- | --- |
|0x01 | cmp eax ebx | eaxレジスタとebxレジスタの値を比較 | 
|0x02 | je dest | eaxレジスタとebxレジスタの値が同じならdestにジャンプ |
| ... |  |  | |

この場合，飽和カウンタは以下のようになる。

|addr(lower bits) | counter |
| --- | --- |
| 0x01 |0 |
| 0x02 |0 → 1 |
| 0x03 |0  |
| ...  |0  |

2回以上続けて分岐が発生すると，次に同じ命令を実行する際は分岐が発生するものとして計算を行う。


### (おまけ)分岐を使わないテクニック

前述したように，パイプライン処理を行うプロセッサにとって条件分岐は敵。
なのでできるだけ条件分岐を使わないコードを書くと実行速度が速くなる(ことがある)。
ただし現在のCPUの分岐予測は高性能なので，プログラムによっては逆に遅くなることもある(実測することが大事)。

例) 最大値を返す関数
if文を使う場合
```
int max(int a, int b) {
   if (a > b)  return a;
   else return b;
}
```
if文を使わない場合
```
int max(int a, int b) {
   int c = a > b;
   return a*c + !b*c;
}
```
