# パスワードの安全な保存方法
最近(2019年1月頃)、宅ファイル便から平文のまま保存されていたパスワードが流出したり、  
質問箱というTwitter連携サービスでハッシュ化したパスワードが流出したりとセキュリティ事故の機運が高まっている(?)。  
そこでwebサービスの運営者としてのパスワードの安全な保管方法について調べてみた。

## 1. (危険な例)平文のまま保存

|UserID|Password|
|:---|:---|
|taro|password|
|hanako|123456|
|satou|abcdefg|

ユーザーが入力したIDとパスワードをDBのデータと比較して認証する。  
SQLインジェクションなどの何らかの脆弱性によりDBの中身が流出した場合に  
ユーザーのパスワードがそのまま流出してしまうので非常によくない。

## 2. ハッシュ化して保存

パスワードをそのまま保存すると危険なので、パスワードをハッシュ化して保存する。  
(ハッシュ化のかわりに暗号化してもいいのだが、暗号化した場合だと復号のための秘密鍵を  
安全な場合に保存する必要がある。そんな場所があるなら鍵ではなくてパスワードをそのまま  
そこに保存すりゃええやんという話なので、現実的ではない)  

|UserID|Password(Hashed)|
|:---|:---|
|taro|5f4dcc3b5aa765d61d8327deb882cf99|
|hanako|e10adc3949ba59abbe56e057f20f883e|
|satou|7ac66c0f148de9519b8bd264312c4d64|

普通は(暗号学的)ハッシュ関数により変換したハッシュ値から変換前の平文を得ることは不可能である  
(そもそもそういうことができたら暗号学的ハッシュ関数とは言えないので)が、  
普通のパスワードの場合は平文全体の集合に"十数桁の英数字からなる文字列"という強い制限がついているため、  
ハッシュ値からもとの平文を復元することができる。

### ハッシュ化したパスワードに対する攻撃
ここでパスワードのハッシュ値からもとのパスワードを復元する方法について考えてみよう。

#### 1. ブルートフォース攻撃
単純に総当たりする。  
あるハッシュ値が与えられた場合に、  
a, b, c, ... と考えられうる平文全てに対してハッシュ値を計算し、最初に与えられたハッシュ値と一致するか調べる。  
当然のことながら、もとの平文の集合が大きくなればなるほど計算に莫大な時間がかかる。  

#### 2. ブルートフォース攻撃(事前計算型)
よくよく考えるとハッシュ値が与えられるまで待たなくとも、あらかじめ平文とハッシュ値の対応表を  
用意しておくことができる。そのような対応表が用意できていれば、攻撃対象のハッシュ値が得られたら  
対応表から平文を調べればよい。この方法では対応表を用意するのには時間がかかるが、  
一度対応表が作れてしまえばハッシュ値から平文をもとめるのに計算時間はかからない。  
しかし、当然のことながらもとの平文の集合が大きくなればなるほど対応表を保存するのに大きな容量が必要になる。  

以下では、攻撃対象のハッシュ値が得られる前に計算を行っておく攻撃のことを事前計算型の攻撃、  
ハッシュ値が得られてから計算を行う攻撃のことを事後計算型の攻撃と呼ぶことにする。

#### 3. 辞書攻撃
パスワードの長さにもよるが、事前計算型にしろ事前計算型にしろブルートフォース攻撃で  
闇雲にもとのパスワードを求めるのは現実的ではない。そこで、総当たりではなくて  
良く使われるパスワードについてのみハッシュ値を調べるという攻撃がある。  
このような攻撃を辞書攻撃という。  

攻撃は、あらかじめ一般的に良く使われるパスワードのリストを手に入れておく。  
事前計算型の攻撃を行う場合は、あらかじめパスワードとそのハッシュ値の対応表を作っておく。  

|PlainText|HashValue|
|:---|:---|
|password|5f4dcc3b5aa765d61d8327deb882cf99|
|123456|e10adc3949ba59abbe56e057f20f883e|
|abcdefg|7ac66c0f148de9519b8bd264312c4d64|

次に、何らかの脆弱性を利用してサービス利用者のIDとパスワードのテーブルを入手する。

|UserID|Password(Hashed)|
|:---|:---|
|taro|5f4dcc3b5aa765d61d8327deb882cf99|
|hanako|e10adc3949ba59abbe56e057f20f883e|
|satou|7ac66c0f148de9519b8bd264312c4d64|

2つのテーブルを参照して、(良く使われるパスワードを利用しているユーザーについては)平文のパスワードを入手することができる。

#### 4. レインボーテーブル
なんかうまいテーブルを作ってハッシュ値から平文を求めるすごいやつだよ  
事前計算型と事後計算型のハイブリッドタイプの攻撃である。

##### 作り方
1. まず、攻撃対象とする平文の集合を決める(8桁の英数字など)
1. 次に、ハッシュ値を1.で決めた平文集合の元に移すような関数(還元関数)をn個用意する。
1. 平文$P^1_0$を適当に選び、$P^1_0$のハッシュ値$C^1_1$を計算する
1. $C^1_1$に還元関数を適用し、平文$P^1_1$を得る
1. 3 4 を繰り返し、平文とハッシュ値のチェーンを作る。
1. $P^1_0$と別の平文$P^2_0$を選び、3 4 5 を繰り返し別のチェーンを得る。
1. これを繰り返し、複数のチェーンが入ったテーブルを作る。
1. レインボーテーブルの各チェーンのスタートの平文とゴールのハッシュ値のみ記録し、他の値を破棄する(記憶容量の削減のため)

平文とハッシュ値のチェーン

$$
P^1_0 \xrightarrow{H} C^1_1 \xrightarrow{R_1} P^1_1 \xrightarrow{H} C^1_2 \xrightarrow{R_2} P^1_2 \ ...\  P^1_{n-1} \xrightarrow{H} C^1_n  \xrightarrow{R_n} P^1_n 
$$
$$
P^2_0 \xrightarrow{H} C^2_1 \xrightarrow{R_1} P^2_1 \xrightarrow{H} C^2_2 \xrightarrow{R_2} P^2_2 \ ...\  P^2_{n-1} \xrightarrow{H} C^2_n  \xrightarrow{R_n} P^2_n
$$
$$
P^3_0 \xrightarrow{H} C^3_1 \xrightarrow{R_1} P^3_1 \xrightarrow{H} C^3_2 \xrightarrow{R_2} P^3_2 \ ...\  P^3_{n-1} \xrightarrow{H} C^3_n \xrightarrow{R_n} P^3_n 
$$
  
完成したレインボーテーブル  

|Start(PlainText)|Goal(Hashed)|
|:---|:---|
|$P^1_0$|$P^1_n$|
|$P^2_0$|$P^2_n$|
|$P^3_0$|$P^3_n$|

##### 使い方
今、あるハッシュ値$c_x$についてハッシュ化する前の平文$p_x$を求めたい。

$$ p_x \xrightarrow{H} c_x $$

攻撃者はまず、ハッシュ値$c_x$について還元関数$R_n$を適用した結果$p^1_n$を計算し、長さ1のチェーンを作る。

$$ c_x \xrightarrow{R_n} p^1_n $$

次にレインボーテーブルの中に$p^1_n$が存在するか調べる。  
レインボーテーブルの中に$p^1_n$が見つからなかった場合、求める平文は$P_{n-1}$のいずれかではないことがわかる。

次に、$c_x$に還元関数$R_{n-1}$を適用し、得られた平文$p^2_{n-1}$にハッシュ関数を適用し、得られたハッシュ値$c^2_{n}$に還元関数$R_n$を適用し長さ2のチェーンを作る。

$$ c_x \xrightarrow{R_{n-1}} p^2_{n-1} \xrightarrow{H} c^2_n \xrightarrow{R_{n}} p^2_n $$

次にレインボーテーブルの中に$p^2_{n}$が存在するか調べる。  
レインボーテーブルの中に$p^2_{n}$が見つからなかった場合、求める平文は$P_{n-2}$のいずれかではないことがわかる。

次はまた同様に$c_x$に$R_{n-2}$を適用し、ハッシュ化と還元を繰り返して長さ3のチェーンを作る。

$$ c_x \xrightarrow{R_{n-2}} p^3_{n-2} \xrightarrow{H} c^3_{n-1} \xrightarrow{R_{n-1}} p^3_{n-1} \xrightarrow{H} c^3_n \xrightarrow{R_n} p^3_n $$

次にレインボーテーブルの中に$p^3_{n}$が存在するか調べる。

ここで仮に$p^3_{n}$がレインボーテーブルの中に見つかり、$P^1_n$と一致したとする。  
攻撃者は$P^1_0$から始まるチェーンを再計算し復元する。

$$ P^1_0 \xrightarrow{H} C^1_1 \xrightarrow{R_1} P^1_1 \xrightarrow{H}  ... \xrightarrow{R_{n-3}} P^1_{n-3} \xrightarrow{H} C^1_{n-2} \xrightarrow{R_{n-2}} P^1_{n-2}  \xrightarrow{H} C^1_{n-1} \xrightarrow{R_{n-1}} P^1_{n-1} \xrightarrow{H} C^1_n \xrightarrow{R_n} P^1_n $$

ここで、$P^1_n$と$p^3_{n}$が一致したのであった。

$$ c_x \xrightarrow{R_{n-2}} p^3_{n-2} \xrightarrow{H} c^3_{n-1} \xrightarrow{R_{n-1}} p^3_{n-1} \xrightarrow{H} c^3_n \xrightarrow{R_n} p^3_n $$

2つのチェーンを比較すれば、$P^1_{n-3}$が求めたい平文であることがわかる。  
元々求めたかった平文$p_x$

$$ p_x \xrightarrow{H} c_x $$

2011年の普通のPCで、MD5でハッシュ化された英字小文字と数字の組み合わせの７桁のパスワードを4秒ちょっとでクラックできるらしい。  
10文字以下の英数字の組み合わせぐらいの平文集合ならすでに計算済みのレインボーテーブルが公開されている。    

[wikipedia: レインボーテーブル](https://ja.wikipedia.org/wiki/%E3%83%AC%E3%82%A4%E3%83%B3%E3%83%9C%E3%83%BC%E3%83%86%E3%83%BC%E3%83%96%E3%83%AB)  
[Free Rainbow Tables](https://freerainbowtables.com/) というサイトでいろいろな平文集合、ハッシュ関数に対応したレインボーテーブルが公開されている。  

## 3. Saltを加えてハッシュ化して保存
単純にハッシュ化しただけでは、上のような攻撃手段で平文のパスワードが求められてしまう。  
そこで、ユーザーごとに異なる何らかの値を用意して、パスワードとその値を組み合わせてハッシュ化し  
そのハッシュ値を保存する方法がある。このような目的で使われる値のことをSaltという。  

|UserID|Password(Hashed)|Salt|
|:---|:---|:---|
|taro|a9280d7f5a5f6aa5dd3af37771427a33|uoar9u4ns|
|hanako|dd0ef952a83bab5319d2399571f3afb2|398fdnaut|
|satou|9f377fcf8c24a0a71436942c403cc1bb|du1l02sia|

Saltを加えてハッシュ化すると同じパスワードであっても異なるハッシュ値になるので、良く使われる脆弱なパスワードを使っていても、もとのパスワードを求めることが難しくなる。また、Saltを加えるということは実質的に長いパスワードを使うことと同じようになるので、レインボーテーブルを用いた攻撃にも強くなる(用意するべきレインボーテーブルが大きくなるため)。Saltはある程度の長さがあって、攻撃者に推測できなくて、ユーザーごとに異なる値であればよい  
(暗号学的な乱数でなくてもよい(暗号学的な乱数であってもよい))。

### Saltが流出した場合の影響

Saltはハッシュ化したパスワードと同じテーブルに保存しているので、ハッシュ化したパスワードが  
なんらかの脆弱性により流出してしまうような状況では同じテーブルに入っているSaltも同様に  
流出してしまうと考えられる。ここでSaltが流出した場合の影響について考えてみよう。  
ハッシュ化したパスワードに対する攻撃方法としては大きく分けて事前計算型と事後計算型の2種類が存在した。  
  
#### 事前計算型攻撃に対するSaltの効果
事前計算型の攻撃というのは、考えられる平文集合に対して予め平文とハッシュ値の対応表を
作っておくというものであった。Saltには少なくとも数十桁の値が使われるので、これだけで  
予め用意するべき対応表が爆発的に大きくなり、実質的に事前計算型の攻撃は不可能になる。  
このような事前計算型の攻撃への対策の場合、Saltはユーザーごとに異なる値である必要すらなく、  
全ユーザーで同じ値をつかっていて同じ効果がある。  

#### 事後計算型攻撃に対するSaltの効果
事後計算型の攻撃の場合、事前計算型のときとは事情が異なってくる。  
Saltを手に入れた攻撃者は、`考えられる平文 + Salt`の組み合わせでハッシュ値を計算する必要がある。    
  
ユーザーごとで同じSaltを使っていた場合、事後計算型の攻撃に対してはほとんど効果が無いといえる。  
  
例えば辞書攻撃の場合、  
password →　5f4dcc3b5aa765d61d8327deb882cf99  
123456　→ e10adc3949ba59abbe56e057f20f883e  
abcdefg　→ 7ac66c0f148de9519b8bd264312c4d64  
  
と計算していたものを  
password + Salt →　...  
123456 + Salt　→ ...  
abcdefg + Salt　→ ...  
  
と計算すればよい。  

ユーザーごとに異なるSaltを使っていた場合、例えばN人のユーザーがいるサービスでは攻撃者が必要な計算の組み合わせはN倍になる。  
  
同じく辞書攻撃の場合、  
password →　5f4dcc3b5aa765d61d8327deb882cf99  
123456　→ e10adc3949ba59abbe56e057f20f883e  
abcdefg　→ 7ac66c0f148de9519b8bd264312c4d64  
  
と計算していたものを  
password + salt1 →　...  
password + salt2 →　...  
password + salt3 →　...  
...  
123456 + salt1　→ ...  
123456 + salt2　→ ...  
123456 + salt3　→ ...  
...  
abcdefg + salt1　→ ...  
abcdefg + salt2　→ ...  
abcdefg + salt3　→ ...  
  
と計算すればよい。  
  
まとめると、Saltは例え流出したとしても、事前計算型の攻撃に対しては圧倒的な効果があり、  
事後計算型の攻撃に対してもそれなりの効果がある。  

## 4. SaltとPepperを加えてハッシュ化して保存

そこで、ハッシュ化の際にSaltとは別にDBに保存されていない値を加えてハッシュ化すればよい。  
このような値のことをPepperという。  
PepperはDBに保存してはいけない代わりに、ユーザーごとに異なる値でなくてよい。  

|UserID|Password(Hashed)|Salt|
|:---|:---|:---|
|taro|3aa981884096cc39e8660c6f369c3a10|uoar9u4ns|
|hanako|fd802360809c0ae2c02e88252b073365|398fdnaut|
|satou|11c7082bce5a40048f6b2b03ca88aee0|du1l02sia|

pepper: H19aMo4kEfP  

(パスワード + Salt + pepper でハッシュ値を計算する)  

こうすれば、何らかの脆弱性によりDBの中身が流出してもpepperが知られない限りハッシュ値からパスワードを求めることはできない。  

要するに重要なポイントは、`パスワード + (ユーザーごとに一意でDBに保存されていない値)`でハッシュ値を作ることである。

## 5. SaltとPepperを加えて複数回ハッシュ化(ストレッチング)して保存

pepperをDBとは別の場所に保存しておけば、SQLインジェクション等の攻撃によりDBの内容が流出したときには効果がある。
しかし、攻撃者がサーバー自体に侵入して設定ファイルや環境変数からpepperを入手した場合にはこの対策は無力である。  

そこで最後の手段として、ストレッチングという手段がある。
これは、パスワードからハッシュ値を求める際に、ハッシュ関数を1回適用するのではなくて、
数千～数万回繰り返し適用するという方法である。
例えばハッシュ関数を一万回適用したハッシュ値を保存しておけば、ハッシュ値から平文を求める際に必要な計算も一万倍になる
(平文とハッシュ値の対応表を作るのに1万倍時間がかかる)。
また、ストレッチングではなくてそもそも最初からハッシュ関数として計算が重いアルゴリズムを使うという方法もある。

これらの方法の欠点は、正規のユーザーの認証にかかる時間も増えてしまうということであるが、それはそれということで広く使われている。
また、ストレッチングをしたところで本当に脆弱なパスワードを使っているユーザーを守れるかというとそこは微妙である。
例えば1万回のストレッチングを行っていた場合、単純に考えて攻撃者が探索できる平文の量はストレッチングをしていない場合の
1万分の1になるが、ユーザーが"password"などの本当に脆弱なパスワードを使っていた場合、真っ先に攻撃対象になる
(辞書攻撃の場合)ので、このようなユーザーはいかにストレッチングを行っていようがどうしようもない。

## まとめ
パスワードはサービスごとに異なる20文字程度のランダムな文字列にして、管理はパスワードマネージャーに任せよう。

## 参考資料

[ハッシュとソルト、ストレッチングを正しく理解する：本当は怖いパスワードの話](http://www.atmarkit.co.jp/ait/articles/1110/06/news154.html)
