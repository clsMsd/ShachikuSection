# 文字コードについて

## 文字コードとは？
文字コードとは、コンピュータで文字を扱う上で各文字に割り当てるバイト表現、又は  
バイト表現と各文字の対応関係のことを表す。  

## Unicode とは？
1. 文字化符号集団
1. (複数の)文字符号化方式(文字コード)
1. 1, 2 を策定する非営利団体(ユニコードコンソーシアム)

の 3つを指すことがあり、普通単に Unicode と言った場合は普通は 1 を指す。  

文字コードを作るということは文字と符号の対応を作るということであるが、  
文字コードを作る前にそもそも符号化する文字の集合を決める必要がある。  
例えば現在用いられている文字コードでは多くの場合 " "(半角スペース) と "　"(和字間隔: ideographic space, いわゆる全角スペース) は異なる文字として扱われているが、  
理屈上はこれらを同一の文字として扱う文字コードがあってもよいし、逆にもっと沢山の種類の空白文字が存在してもよい(というか実際Unicodeでは15種類ほどの空白文字が存在する) 。  
このように、文字コードを作る前にどのような文字を同じ文字として扱い、どのような文字を違う文字として扱うのか、  
コード化する文字の集合を決める必要がある。  

Unicode とは、世界中で使われている文字を特定し、それらの文字を区別できるように 1つづつ番号を割り当てたものである。  
このときに文字に割当てられる数字のことを、ユニコードのコードポイントという。  

|文字|Unicode Code Point(16進数)|Unicode Code Point(10進数)|
|:--|:--|:--|
|a|61|97|
|あ|3042|12354|
|亜|4e9c|20124|
|🤔|1f914|129300|

ユニコードコードポイントの値であることを表す場合は U+(16進数) という表記を使うことが多い。  
プログラミング言語によっては、ソースコードの文字列中に直接コードポイントを書いて文字を表すということもできる。  

python3 の例
```python
print("\u0061") #=> a
print("\u3042") #=> あ
print("\U0001f914") #=> 🤔
```

コードポイントは数字なので符号として扱うこともでき、実際に utf-32 とよばれる文字コードでは  
ユニコードのコードポイントがそのまま文字の符号 として扱われている。

また、もともとユニコードコンソーシアムでは文字符号化方式として UTF-16 (厳密にいうとその前身である UCS-2)  
のみが策定されていて、Unicode = UTF-16 として扱われていた。  

後に UTF-8 や UTF-32 といった Unicode の別の符号化体系が作られたのだが、 Windowsのメモ帳などはかなり長い間 Unicode = UTF-16  
として扱っていたので、今でも時々 Unicode = UTF-16 だと思っていたり、そのように扱いになっているプログラムが存在しているので注意が必要である。    

<!-- 文字コードとして Unicode が使われている WindowsXP 時代のメモ帳の表示 (実態は UTF-16)  
<img src="./topics9_3.png" /> -->

## いろいろな文字コード

### ASCII
American Standard Code for Information Interchange の略。   
128個のアルファベット・数字・記号・制御文字等が <b>7bit</b> のbit列にエンコードされる。  
ASCII以外の文字コードであってもASCIIに含まれる文字はASCIIと同じコードになっているものがほとんどである。  

元々はコンピュータ用というよりもテレタイプ(遠隔で操作できるタイプライタ)用に作られた  
(といっても当時のコンピュータはだいたいテレタイプで出力を行っていたのでコンピュータ用ともいえるが)。  

1963年に規格が制定されたときはアルファベットの小文字が含まれておらず、1967年に規格が改定されて大文字が含まれるようになった。  

テレタイプ用に作られたので、テレタイプ向けの制御文字が大量に含まれている。  
規格が制定された当時はこれでもまだ制御文字が少ないと思われており、さらに多くの制御文字を足す提案もあったらしい。  

[https://zariganitosh.hatenablog.jp/entry/20150209/ascii_code_secrets]  

|制御文字|16進数表示|意味|
|:--|:--|:--|:--|
|NUL|00|ヌル文字|
|SOH|01|ヘディング開始|
|STX|02|テキスト開始|
|ETX|03|テキスト終了|
|EOT|04|伝送終了|
|ENQ|05|問い合わせ|
|ACK|06|肯定応答|
|BEL|07|ベル|
|BS|08|後退|
|HT|09|水平タブ|
|LF|0A|改行|
|VT|0B|垂直タブ|
|FF|0C||
|CR|0D|復帰|
|SO|0E|シフトアウト|
|SI|0F|シフトイン|
|DLE|10|伝送制御拡張|
|DC1|11|制御装置1|
|DC2|12|制御装置2|
|DC3|13|制御装置3|
|DC4|14|制御装置4|
|NAK|15|否定応答|
|SYN|16|同期信号|
|ETB|17|伝送ブロック終結|
|CAN|18|取り消し|
|EN|19|媒体終端|
|SUB|1A|置換|
|ESC|1B|エスケープ|
|FS|1C|ファイル分離標識|
|GS|1D|グループ分離標識|
|RS|1E|レコード分離標識|
|1F|US|ユニット分離標識|
|7F|DEL|削除|

(ASCII制定当時のものも含めて)ほとんどのコンピュータは8bitを1byteとして扱うが、ASCIIは7bitの文字コードなので1bitあまる。  
あまりの1bitは元々はエラーチェックのパリティビット用に確保されていたが、後々にASCIIの拡張文字コードを作るときに使われた。  

### Shift_JIS (JIS X 208:1997)
ASCIIは英語圏で使用する文字しか文字コードが定められていないので、  
漢字・ひらがな・カタカナ・ギリシャ文字・キリル文字等の非英語圏で使用する文字をコンピュータ上で扱うには別の文字コードを使用する必要があった。  

Shift_JISはそのような日本語向けの文字コードである。  

Shift_JISは 8bit or 16bitの可変長の文字コードであり、ASCIIに含まれる文字はASCIIと互換性がある。  
また、8bit で収まる範囲でASCIIで使われていない領域に半角カタカナという文字が割り当てられている。

### UTF-32
ユニコードコードポイントをそのまま文字符号として扱う、32bitの固定長文字コード。  
1文字を表すのに32bit必要なので効率が悪い。  
また、後述するようにutf-32を使ったとしても画面上の一文字を固定長のバイト列で表すことは実はできないので  
微妙にいいところがなくあまり使われていない。  

### UTF-16 (UCS-2)
もともとユニコードで使われることを想定して作られた文字コード。  
16bitの固定長の文字コードで1文字を表すことを想定していた(この文字コードはUCS-2と呼ばれる)が、  
後に16bitでは世界中の文字を表すのに足りないということで拡張され、16bit or 32bitの可変長の文字コードとなった。  
基本は1文字16bitだが、難しい漢字など使用頻度が低くて後から割り当てられた文字は32bitで1文字になっている(サロゲートペア文字)。

ユニコードの規格制定時に世界中の新聞と雑誌で使われている文字を調査したところ、2^14個よりもずっと少なかったため  
2^16もあれば世界中の文字を表すのに十分だろうと考えられたらしい。  

ユニコードの初期ドラフト  
http://unicode.org/history/unicode88.pdf

### UTF-8
8bit ~ 48bit(6byte) の可変長文字コード。  
ASCIIと並んで恐らく今現在もっとも広く普及している文字コードである。  
ASCIIの範囲ではASCIIと互換性があるのでサーバー等の移行がやりやすかったらしい。  

可変長のエンコードなので、ある文字列中の N番目の文字を取り出すというような操作を行う場合に O(n) の時間がかかる。
SwiftやRustなどの最近の言語では文字列のN番目を取り出すのにメソッドを経由する必要があるが、だいたいこのせいである。
(とはいえ utf16でもサロゲートペアをちゃんと扱う場合は同じ処理が必要である)

## 結合文字
世の中の文字の中には2つ以上の文字がくっついて1つの文字になるものがある。  
日本語でわかりやすい例として、濁点・半濁点がある。  

例えばUnicodeでは単独で濁点（U+3099）の文字コードが割り当てられているので、  
`で` というという文字を表すのに、1コードポイント（U+3067）で表す方法と、  
2コードポイント (`て`(U+3066) + `濁点` (U+3099)) で表す2通りの方法がある。  

このような(見かけ上の)1文字を2つ以上のコードポイントで表すとき、元となる文字(今回は`て`)のことを 基底文字(Base Character)、  
後続する文字(今回は`濁点`)のことを 結合文字(Combining Character) という。  
(ちなみに結合文字でない濁点(`゛`: U+309B)も別に存在する)

```python
print("\u3067")
print("\u3066\u3099")
print("\u3067\u309B")
```

日本語の濁点・半濁点の他に、ラテン文字ではアクセント・ウムラウト・チルダなどのダイアクリティカルマークで使われる他、  
ハングル、デーヴァナーガリー、音符、絵文字などさまざまな文字が結合文字を使って表される。  

デーヴァナーガリーの例
```python
print("\u092A\u0942\u0930\u0940\u0924\u093F") #=> पूरीति
```

ユニコードコードポイントとは別に、見かけ上の1文字のことを書記素(grapheme)という。  
プログラムで文字列の長さを取得する場合、たいていは書記素単位の長さではないので、  
こうした結合文字の長さを取得すると見かけ上おかしな数になる。  

## 実際にバイト列を見てみる
Pythonで次の関数を作って、いろいろな文字コードによるいろいろな文字のバイト列を表示してみる
```python
def show_bytesequence(a):
   print(a)
   try:
      print("code point: ", hex(ord(a)))
   except Exception as e:
      print(e)
   try:
      print("ascii:     ", a.encode("ascii").hex())
   except Exception as e:
      print(e)
   try:
      print("shift_jis: ", a.encode("shift_jis").hex())
   except Exception as e:
      print(e)
   print("utf-8:     ", a.encode("utf-8").hex()
   print("utf-16be:  ", a.encode("utf-16be").hex()
   print("utf-16le:  ", a.encode("utf-16le").hex()
   print("utf-16:    ", a.encode("utf-16").hex()
   print("utf-32be:  ", a.encode("utf-32be").hex()
   print("utf-32le:  ", a.encode("utf-32le").hex()
   print("utf-32:    ", a.encode("utf-32").hex()
```

### 「A」
```
A
code point: 0x41
ascii:      41
shift_jis:  41
utf-8:      41
utf-16be:   0041
utf-16le:   4100
utf-16:     fffe4100        
utf-32be:   00000041        
utf-32le:   41000000        
utf-32:     fffe000041000000
```

### 「あ」
```
あ
code point: 0x3042
shift_jis:  82a0
utf-8:      e38182
utf-16be:   3042
utf-16le:   4230
utf-16:     fffe4230        
utf-32be:   00003042        
utf-32le:   42300000
utf-32:     fffe000042300000
```
Asciiではエンコードできない。  

### 「増」
```
増
code point: 0x5897
shift_jis:  919d
utf-8:      e5a297
utf-16be:   5897
utf-16le:   9758
utf-16:     fffe9758
utf-32be:   00005897
utf-32le:   97580000
utf-32:     fffe000097580000
```

### 「𩸽」
```
𩸽
code point: 0x29e3d
utf-8:      f0a9b8bd
utf-16be:   d867de3d
utf-16le:   67d83dde
utf-16:     fffe67d83dde
utf-32be:   00029e3d
utf-32le:   3d9e0200
utf-32:     fffe00003d9e0200
```
サロゲートペア文字なので、utf-16エンコードでも32bitのバイト列になっている。  

### 「🤔」
```
🤔
code point: 0x1f914
utf-8:      f09fa494
utf-16be:   d83edd14
utf-16le:   3ed814dd
utf-16:     fffe3ed814dd
utf-32be:   0001f914
utf-32le:   14f90100
utf-32:     fffe000014f90100
```
同じくサロゲートペア文字なので、utf-16エンコードでも32bitのバイト列になっている。  

### 「👨‍👩‍👧‍👦」
```
👨‍👩‍👧‍👦
ord() expected a character, but string of length 7 found
utf-8:      f09f91a8e2808df09f91a9e2808df09f91a7e2808df09f91a6
utf-16be:   d83ddc68200dd83ddc69200dd83ddc67200dd83ddc66
utf-16le:   3dd868dc0d203dd869dc0d203dd867dc0d203dd866dc
utf-16:     fffe3dd868dc0d203dd869dc0d203dd867dc0d203dd866dc
utf-32be:   0001f4680000200d0001f4690000200d0001f4670000200d0001f466
utf-32le:   68f401000d20000069f401000d20000067f401000d20000066f40100
utf-32:     fffe000068f401000d20000069f401000d20000067f401000d20000066f40100
```

## 参考資料
[https://qiita.com/yumetodo/items/54e1a8230dbf513ea85b]  
[https://www.atmarkit.co.jp/ait/articles/1604/27/news051.html]  
[https://qiita.com/PND/items/17e87b8839c9099d2e70]
