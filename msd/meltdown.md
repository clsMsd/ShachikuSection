# meltdown 脆弱性

## 概要

あるプロセスから，アクセス権限のないメモリ領域(別プロセスやカーネルの使用領域)を読み込むことができてしまう脆弱性。  
キャッシュアクセスの時間差を利用した典型的なサイドチャネル攻撃である。

## exploit code

下準備
```
char* kernel_addr;            // 攻撃者はあらかじめカーネルのアドレスを知っている必要がある
char probe_array[256 * 4096]  // プローブとして使う配列を確保
// キャッシュはあらかじめクリアしておく
```
実行
```
a = *kernel_addr;           // カーネルのメモリを読み込む(例外が発生)
b = probe_array[a * 4096];  // 本来ならばこのコードは実行されないが，アウトオブオーダー実行のため実行される
// この後，probe_array のうちアクセス速度が速いindexを探す
```
<p>
1行目のコードで例外が発生するため，本来は2行目のコードは実行されないはずなのだが，  
実際はアウトオブオーダー実行のために2行目まで実行される。
しかし，2行目の命令の実行結果はクリアされるためメモリやレジスタにはその痕跡は残らない。
しかし，キャッシュには2行目の命令で読み込んだ`probe_array[a * 4096]`の値が残っている。
したがって，`probe_array`のうちindex が`a * 4096`のものだけが読み込み速度が極端に速くなる
→ 読み込み速度が速いindexから，`a`(カーネルメモリの値)を逆算できる！
(4096を掛けている理由は，ページサイズ(4kB)を超えた間隔でデータを配置しハードウェアプリフェッチを起こさないようにするため)
</p>

## 実行結果

![file](https://densho-crowi.s3.amazonaws.com/attachment/5a7a88d68b720f0004515606/a11751f187cda97e9415c95105065a87.PNG)
(参考文献[1]より引用)

この例では，84番目の要素のみ読み込みが非常に速い。つまり`*kernel_addr`の値は84であることが分かる。

## Q & A

#### Q. 2行目の命令が1行目の結果に依存しているので，1行目の命令が完了しないと2行目が実行できないのでは？    

アウトオブオーダー実行を行う際，前の命令の結果をオペランドとする命令がある場合，前の命令の結果がWBされる前に
レジスタやメモリを介さずに直接オペランドをフェッチする機能がある。そのため，1行目の命令でメモリから値がロードされてから
例外が発行されるまでの時間，アクセス権限のないメモリの値を読み込むことができる。

#### Q. どうしてメモリを読み込む前に権限チェックを行わないのか？

アクセス時間を短縮するため。アクセス権限をチェックしてからメモリを読み込むよりも，とりあえずメモリを読み込みながら
その時間で権限チェックを行った方が速い。

## 対策
1. out-of-order実行をやめる
→ 性能が低下する
1. メモリにアクセスする前に権限チェックを行う
→ 性能が低下する
1. ユーザープロセスとカーネルプロセスでページテーブル(論理アドレスと物理アドレスの対応表)を分離する
→ ユーザープロセスからカーネルのメモリ領域にアクセスすることが物理的に不可能になる
　 (物理アドレスを知ることができなくなる)

## 参考文献
[1] Lipp, Moritz, et al. "Meltdown." arXiv preprint arXiv:1801.01207 (2018).
